"""
コード3.3 ■ 非線形共役勾配法（Nonlinear Conjugate Gradient Method, Hestenes-Stiefel法：点列ログ付き）
このプログラムは、非線形最適化における高速な勾配法「非線形共役勾配法（Hestenes-Stiefel法）」を実装している。
最急降下法の改良版であり、過去の探索方向を考慮して効率的に最小点を探索する。
各反復ステップで得られた点を記録する点列ログ機能を持つ。
"""

import numpy as np
from code2_2 import *  # Wolfe条件を用いた線探索アルゴリズム（コード2.2）をインポート


def CG_HS(obj_f, nab_f, x_k, max_iter=1000, eps=1.0e-8):
    """
    非線形共役勾配法（Hestenes-Stiefel法）による最適化を行い、点列ログを出力する関数。

    Parameters
    ----------
    obj_f : function
        最小化したい目的関数 f(x)
    nab_f : function
        目的関数の勾配（∇f(x)）を返す関数
    x_k : ndarray
        初期点（探索の開始点）
    max_iter : int, optional
        最大反復回数（デフォルト: 1000）
    eps : float, optional
        収束判定の閾値。勾配ノルムがこの値以下になると終了（デフォルト: 1e-8）

    Returns
    -------
    seq_x : ndarray
        各反復ステップでの点 x_k を順に格納した配列
    """

    # ------------------------------------------------------------
    # (1) 初期化
    #   - 初期点での勾配を計算
    #   - 最初の探索方向は負の勾配方向
    #   - 点列ログを格納するリストを初期化
    # ------------------------------------------------------------
    nab_f_k = nab_f(x_k)  # 現在の勾配 ∇f(x_k)
    d_k = -nab_f_k  # 初期探索方向（最急降下方向）
    seq_x = [x_k]  # 初期点をログに追加

    # ------------------------------------------------------------
    # (2) 反復ループ
    # 各ステップで Wolfe 条件に基づいて線探索を行い、
    # Hestenes-Stiefel（HS）公式で次の探索方向を計算。
    # ------------------------------------------------------------
    for k in range(max_iter):

        # (2-1) Wolfe条件による線探索（最適ステップ幅 α の決定）
        alpha = line_Wolfe(obj_f, nab_f, x_k, d_k)

        # (2-2) 探索点を更新：x_{k+1} = x_k + α * d_k
        x_k = x_k + alpha * d_k
        seq_x.append(x_k)  # 新しい点をログに追加

        # (2-3) 勾配の更新
        nab_f_k_old = nab_f_k
        nab_f_k = nab_f(x_k)

        # (2-4) 収束判定：勾配ノルムが小さければ終了
        if np.linalg.norm(nab_f_k) <= eps:
            break

        # --------------------------------------------------------
        # (2-5) Hestenes-Stiefel法による β の更新式
        #   β_HS = (∇f_k^T (∇f_k - ∇f_{k-1})) / (d_{k-1}^T (∇f_k - ∇f_{k-1}))
        #   この β により、前回方向と共役な新しい探索方向を得る。
        # --------------------------------------------------------
        beta = nab_f_k @ (nab_f_k - nab_f_k_old) / (d_k @ (nab_f_k - nab_f_k_old))

        # (2-6) 探索方向の更新：d_k = -∇f_k + β * d_{k-1}
        d_k = -nab_f_k + beta * d_k

    # ------------------------------------------------------------
    # (3) 結果出力
    # 反復回数と最終目的関数値を表示
    # ------------------------------------------------------------
    print("CG(HS), iter:", k + 1, "f(x):", obj_f(x_k))

    # ------------------------------------------------------------
    # (4) 点列ログをNumPy配列に変換して返す
    # 各行が各ステップの点ベクトルを表す
    # ------------------------------------------------------------
    return np.array(seq_x)
