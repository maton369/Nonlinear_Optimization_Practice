"""
コード4.3 ■ BFGS 法（準ニュートン法：H 公式） のコード（説明コメント付き）
本コードは、逆ヘッセ近似 H_k ≈ (∇²f(x_k))^{-1} を BFGS（H 公式）で更新しつつ、
Wolfe 条件に基づく線探索でステップ幅を決定する準ニュートン法を実装するものである。
収束判定は勾配ノルム ||∇f(x_k)|| ≤ eps により行うである。
"""

import numpy as np
from code2_2 import *  # Wolfe 条件に基づく線探索（line_Wolfe）を読み込むである
from code4_2 import *  # BFGS の H 公式（BFGS_H）を読み込むである


def QuasiNewton(obj_f, nab_f, x_k, max_iter=1000, eps=1.0e-8):
    """
    準ニュートン法（BFGS：H 公式）により最小化問題の解を探索するである。

    Parameters
    ----------
    obj_f : callable
        目的関数 f(x) を返す関数である。
    nab_f : callable
        勾配 ∇f(x) を返す関数である。
    x_k : np.ndarray
        初期点ベクトルである（形状 (n,) を想定）。
    max_iter : int, default=1000
        最大反復回数である。
    eps : float, default=1e-8
        収束判定の閾値である（||∇f(x_k)|| ≤ eps で停止）。

    Returns
    -------
    np.ndarray
        最終反復で得られた点 x_k である。
    """

    # ------------------------------------------------------------
    # 初期化：
    #   - 逆ヘッセ近似 H_0 は単位行列 I とする（無情報事前）である。
    #   - 勾配 g_k = ∇f(x_k) を計算して保持するである。
    # ------------------------------------------------------------
    H_k = np.identity(len(x_k))  # H_0 = I：対称正定値を保証する初期化である
    nab_f_k = nab_f(x_k)  # g_k = ∇f(x_k)

    for k in range(max_iter):
        # --------------------------------------------------------
        # (1) 探索方向 d_k を決定するである
        # 準ニュートン法ではニュートン方向の近似として
        #   d_k = - H_k ∇f(x_k)
        # を用いる。H_k が良い近似であるほどニュートン法に近い挙動となるである。
        # --------------------------------------------------------
        d_k = -H_k @ nab_f_k

        # --------------------------------------------------------
        # (2) Wolfe 条件に基づく線探索でステップ幅 α を求めるである
        # 過小・過大ステップを避け、安定な減少と曲率条件を満たすよう調整するである。
        # --------------------------------------------------------
        alpha = line_Wolfe(obj_f, nab_f, x_k, d_k)

        # --------------------------------------------------------
        # (3) 点と勾配の更新に備え、旧値を保存するである
        # --------------------------------------------------------
        x_k_old, nab_f_k_old = x_k, nab_f_k

        # --------------------------------------------------------
        # (4) 点を更新し、新しい勾配を評価するである
        #   x_{k+1} = x_k + α d_k
        #   g_{k+1} = ∇f(x_{k+1})
        # --------------------------------------------------------
        x_k = x_k + alpha * d_k
        nab_f_k = nab_f(x_k)

        # --------------------------------------------------------
        # (5) 収束判定：勾配ノルムが十分小さければ終了するである
        # --------------------------------------------------------
        if np.linalg.norm(nab_f_k) <= eps:
            break

        # --------------------------------------------------------
        # (6) BFGS の更新量 s_k, y_k を計算するである
        #   s_k = x_{k+1} - x_k
        #   y_k = g_{k+1} - g_k
        # 以後、H_{k+1} は BFGS(H) 公式で更新するである。
        #   H_{k+1} = H_k
        #            - (H_k y_k s_k^T + s_k y_k^T H_k) / (s_k^T y_k)
        #            + (1 + (y_k^T H_k y_k) / (s_k^T y_k)) * (s_k s_k^T) / (s_k^T y_k)
        # 重要：曲率条件 s_k^T y_k > 0 を満たすとき、H_{k+1} の正定性が保たれるである。
        # --------------------------------------------------------
        s_k = x_k - x_k_old
        y_k = nab_f_k - nab_f_k_old

        # BFGS 公式による逆ヘッセ近似の更新である。
        # 実装側（code4_2.BFGS_H）では曲率条件のガードや対称化を行う設計が望ましいである。
        H_k = BFGS_H(H_k, s_k, y_k)

    # ------------------------------------------------------------
    # ログ出力：反復回数と最終目的関数値を表示するである
    # ------------------------------------------------------------
    print("QNewton, iter:", k + 1, "f(x):", obj_f(x_k))
    return x_k
